<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html,body,all
{
  height: 100%;
  margin: 0px;
  padding: 0px;
}

#map_canvas
{
  width:100%;
  height:94%;
}

#options
{
   width:100%;
   height:1.4em;
   clear: both;
}

</style>
<script type="text/javascript" src="static/jquery-1.4.2.min.js"></script>
<script type="text/javascript"
    src="http://maps.google.com/maps/api/js?sensor=false">
</script>
<script type="text/javascript">
   var image_cache = new Object(); // heading -> marker
   var path_cache = new Object();  // route -> path[]
   var bus_cache = new Object();   // route -> bus[]

   var stop_image = new google.maps.MarkerImage(
       "static/stop.png",
       new google.maps.Size(8, 8), // size
       new google.maps.Point(0, 0), // origin
       new google.maps.Point(4, 4) //anchor
   );

   function curtime() {
      return (new Date()).getTime()/1000;
   }

   function load_image(heading) {
      if (image_cache[heading] == null) {
         image_cache[heading] = new google.maps.MarkerImage(
            "http://www.google.com/intl/en_ALL/mapfiles/dir_" + heading + ".png",
            new google.maps.Size(24, 24), // size
            new google.maps.Point(0, 0), // origin
            new google.maps.Point(12, 12) //anchor
         );
      }
      return image_cache[heading];
   }

   var max_lat = null;
   var min_lat = null;
   var max_lng = null;
   var min_lng = null;

   function distance(x1,y1,x2,y2) {
     // really distance squared, but no one cares
     return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
   }

   function closest_point_on_line(x1, y1, x2, y2, x3, y3) {
      // from http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/
      var u = ((x3-x1)*(x2-x1) + (y3-y1)*(y2-y1)) / distance(x1, y1, x2, y2);

      if (u < 0 || u > 1) {
         // use one of the ends
         if (distance(x1,y1,x3,y3) > distance(x2,y2,x3,y3)) {
             return [x2,y2];
         }
         else {
             return [x1,y1];
         }
      }
      else {
        // use a point on the line

        var x4 = x1 + u*(x2 - x1);
        var y4 = y1 + u*(y2 - y1);

        return [x4,y4];
      }
   }

   function distance_to_line(x1, y1, x2, y2, x3, y3) {
      var cpol = closest_point_on_line(x1, y1, x2, y2, x3, y3);
      return distance(cpol[0], cpol[1], x3, y3);
   }


   function snap_to_path(route, lat, lon) {
     var best_line = null;
     var best_dist = null;

     if (!(route in path_cache)) {
        return [lat, lon];
     }

     paths = path_cache[route];

     for (path_no in paths) {
        for (point_no in paths[path_no]) {
           if (point_no > 0) {
              var p_i = paths[path_no][point_no-1];
              var p_j = paths[path_no][point_no];
              var dist = distance_to_line(p_i.lat, p_i.lon, p_j.lat, p_j.lon, lat, lon);
              if (best_line == null || dist < best_dist) {
                 best_line = [p_i.lat, p_i.lon, p_j.lat, p_j.lon];
                 best_dist = dist;
              }
           }
        }
     }

     if (best_line == null || best_dist > .00001) {
        // if we failed to find a good line, or if we'd be adjusting too far, do nothing
        return [lat,lon];
     }
     return closest_point_on_line(best_line[0], best_line[1],
                                  best_line[2], best_line[3],
                                  lat, lon);
   }

   function estimate_pos(age_i, age_j, req_time, l_i, l_j, t_k) {
     var t_i = req_time - age_i;
     var t_j = req_time - age_j;

     if (Math.abs(l_i - l_j) < .00001 || t_i == t_j) {
        return l_j;
     }

     var delta_t = t_j - t_i;
     var delta_l = l_j - l_i;
     var l_k = l_j + (t_k-t_j)*(l_j-l_i)/(t_j-t_i);
     return l_k;
   }


   function update_bounds(lat, lng) {
     if (max_lat == null || lat > max_lat ) { max_lat = lat; }
     if (min_lat == null || lat < min_lat ) { min_lat = lat; }

     if (max_lng == null || lng < max_lng ) { max_lng = lng; }
     if (min_lng == null || lng > min_lng ) { min_lng = lng; }
   }

   function initialize() {
    var latlng = new google.maps.LatLng(42.3, -71.1);
    var myOptions = {
      zoom: 11,
      center: latlng,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    var map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);

    function recenter () {
       if (max_lat != null && min_lat != null && max_lng != null && min_lng != null) {
          var sw = new google.maps.LatLng(min_lat, max_lng);
          var ne = new google.maps.LatLng(max_lat, min_lng);
          map.fitBounds(new google.maps.LatLngBounds(sw, ne));
       }
    }

    function get_bus_position(bus, route, t_now)
    {
       if (document.settings.est.checked) {
          lat = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lat_i, bus.lat_j, t_now);
          lon = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lon_i, bus.lon_j, t_now);
       }
       else
       {
          lat = bus.lat_j;
          lon = bus.lon_j;
       }

       if (document.settings.snap.checked) {
          cpol = snap_to_path(route, lat, lon);
          lat = cpol[0];
          lon = cpol[1];
       }

       return [lat, lon]
    }


    function plot_buses(route, busarr) {
       timestamp = bus_cache[route][0];
       buses = bus_cache[route][1];

       for (bus_no in buses) {
          var bus = buses[bus_no];
          var busid = route + ":" + bus.id;
          var bus_title = busid + " -- age " + bus.age_j;

          var t_now = curtime();
          var lat_lon = get_bus_position(bus, route, t_now);
          var lat_lon_1 = get_bus_position(bus, route, t_now+5);

          if (document.settings.esth.checked)
          {
             // update heading
             var delta_lat = lat_lon_1[0] - lat_lon[0];
             var delta_lon = lat_lon_1[1] - lat_lon[1];
             if (Math.abs(delta_lat) > 0.000001 && Math.abs(delta_lon) > 0.000001)
             {
                //var theta_r = Math.atan2(-delta_lat,-delta_lon);
                var theta_r = Math.atan2(delta_lon,delta_lat);
                var theta_d = (180*theta_r/Math.PI+360)%360;
                bus.rhead = Math.round(theta_d)%120;
             }
          }

          var blatlng = new google.maps.LatLng(lat_lon[0], lat_lon[1]);

          if (busarr[busid] == null) {
            var bmarker = new google.maps.Marker({
              position: blatlng,
              title:bus_title + " (new)"
            });
            busarr[busid] = bmarker;
            bmarker.setMap(map);
          }

          busarr[busid].setIcon(load_image(bus.rhead));
          busarr[busid].setPosition(blatlng);
          busarr[busid].setTitle(bus_title);

          // only update for paths
          //update_bounds(lat, lon);
       }
    }


    function draw_buses(map, busarr, route) {
       // only request from server every 15 sec
       if (route in bus_cache && (curtime() - bus_cache[route][0] < 15 || bus_cache[route][0] == -1)) {
          plot_buses(route, busarr);
       }
       else {
          bus_cache[route] = [-1, []]; // so that we know we are updating and don't plot

          $.getJSON('/Buses?route=' + route, function(buses) {
              bus_cache[route] = [curtime(), buses];
              plot_buses(route, busarr);
          });
       }
    }

    function draw_buses_continual(map, busarr, buses) {
      setInterval(function() {
        draw_buses(map, busarr, buses); },
        100
      );
    }

    function draw_routes(map, route, busarr) {

      {% if shading %}
      $.getJSON('/Buses?route=' + route, function(buses) {
         var n_buses = buses.length;
         var opacity = n_buses/10;
         //var opacity = 1.0;
         var weight = n_buses/8+1;
         //var weight = n_buses/4+1;
      {% else %}
         var opacity = 1.0;
         var weight = 2.0;
      {% endif %}

         $.getJSON('/Paths?route=' + route, function(r) {
            path_cache[route] = r.paths;

            for (path_no in r.paths) {
               var coords = new Array();
               for (point_no in r.paths[path_no]) {
                   var point = r.paths[path_no][point_no];
                   update_bounds(point.lat, point.lon)
                   coords.push( new google.maps.LatLng(point.lat, point.lon) );
               }

               var buspath = new google.maps.Polyline({
                   path: coords,
                   strokeColor: "#FF0000",
                   strokeOpacity: opacity,
                   strokeWeight: weight
               });

               buspath.setMap(map);
               google.maps.event.addListener(buspath, "click", function() {
                 draw_buses(map, busarr, route);
               });

               recenter();
            }

            {% if stops %}
              for (stop_no in r.stops) {
                var stop = r.stops[stop_no];
                var slatlng = new google.maps.LatLng(stop.lat, stop.lon);

                var smarker = new google.maps.Marker({
                  position: slatlng,
                  title: stop.title,
                  icon: stop_image,

                  map: map
                });
              }
            {% endif %}

            {% if buses %}
               draw_buses_continual(map, busarr, route);
            {% endif %}
         });

      {% if shading %}
      });
      {% endif %}
    }

    {% if all_routes %}
      $.getJSON('/Routes', function(routes) {
         for (route_no in routes) {
            var tag = routes[route_no][0];
            var title = routes[route_no][1];
            draw_routes(map, tag, new Object());
         }
      });
    {% else %}
       {% for route in routes %}
          draw_routes(map, {{route}}, new Object());
       {% endfor %}
    {% endif %}


   }





</script>
</head>
<body onload="initialize()">
  <div id="all" style="height: 100%">
  <div id="map_canvas"></div>
  <div id="options">

    <form name="settings">
      <input type="checkbox" name="est" checked="{{est}}"> Estimate Locations &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="esth" checked="true"> Estimate Headings &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="snap" checked="{{snap}}"> Snap to Route
    </form>

  </div>
  </div>
</body> </html>
