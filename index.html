<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html,body,all
{
  height: 100%;
  margin: 0px;
  padding: 0px;
}

#map_canvas
{
  width:100%;
  height:94%;
}

#options
{
   width:100%;
   height:1.4em;
   clear: both;
}

</style>
<script type="text/javascript" src="static/jquery-1.4.2.min.js"></script>
<script type="text/javascript"
    src="http://maps.google.com/maps/api/js?sensor=false">
</script>
<script type="text/javascript">

   var default_path_opacity = 0.5;
   var active_path_opacity = 1.0;

   // route ->
   //  path_cache -> direction -> paths[points[]]
   //  path_lines -> direction -> polylines[]
   //  bus_cache -> [last update, businfo]
   //  stops[]
   //  buses[]
   var routes = new Object();

   times_info_window = new google.maps.InfoWindow({
     content: "not set yet"
   });


   var image_cache = new Object(); // heading -> marker

   var current_colored_path = null;


   /* all this Overlay stuff is to get projections */
   /* from: http://stackoverflow.com/questions/1538681/how-to-call-fromlatlngtodivpixel-in-google-maps-api-v3 */
   function MyOverlay(options) {
      this.setValues(options);
      var div = this.div_= document.createElement('div');
      div.className = "overlay";
   };
   MyOverlay.prototype = new google.maps.OverlayView;
   MyOverlay.prototype.onAdd = function() { var pane = this.getPanes().overlayLayer; pane.appendChild(this.div_); }
   MyOverlay.prototype.onRemove = function() { this.div_.parentNode.removeChild(this.div_); }
   MyOverlay.prototype.draw = function() {}

   function merge_stop_predictions(map) {
     var OverLayMap = new MyOverlay( { map: map } );

     stop_markers = [];
     for (route in routes) {
       for (stop_no in routes[route].stops) {
         stop_markers.push(routes[route].stops[stop_no]);
       }
     }

     for (i in stop_markers) {
        stop_markers[i].titles = [];
        stop_markers[i].stop_tags = [stop_markers[i].stop_tag];
     }

     var p = OverLayMap.getProjection();
     if (p == undefined) {
        return;
     }


     function pixel_distance(marker_i, marker_j) {
        var p_i = p.fromLatLngToDivPixel(marker_i.getPosition());
        var p_j = p.fromLatLngToDivPixel(marker_j.getPosition());

        return distance(p_i.x, p_i.y, p_j.x, p_j.y);
     }

     for (i in stop_markers) {
        for (j in stop_markers) {
           if (i > j) {
               var stop_i = stop_markers[i];
               var stop_j = stop_markers[j];
               var pd = pixel_distance(stop_i, stop_j);
               if (pd < 5*5) {
                   if (stop_i.title != stop_j.title) {
                      if ($.inArray(stop_j.title, stop_i.titles) == -1) { stop_i.titles.push(stop_j.title); }
                      if ($.inArray(stop_i.title, stop_j.titles) == -1) { stop_j.titles.push(stop_i.title); }
                   }
                   if ($.inArray(stop_j.stop_tag, stop_i.stop_tags) == -1) { stop_i.stop_tags.push(stop_j.stop_tag); }
                   if ($.inArray(stop_i.stop_tag, stop_j.stop_tags) == -1) { stop_j.stop_tags.push(stop_i.stop_tag); }
                   //console.debug("merged " + stop_j.title + " and " + stop_i.title + " (" + pd + ")");
               }
            }
         }
      }
   }


   function get_color(active, route) {
      colors = {"Red": {"active": "#CC0000",
                        "inactive": "#FF0000"},
                "Orange": {"active": "#FF7700",
                           "inactive": "#FF5500"},
                "Blue": {"active": "#0000CC",
                         "inactive": "#1900FF"},
                "Bus": {"active": "#B404AE",
                        "inactive": "#FE2EF7"}}
      if (route in colors) { return colors[route][active]; }
      else { return colors["Bus"][active]; }
   }


   function is_subway(route) {
     return route == "Red" || route == "Blue" || route == "Orange";
   }

   var bus_times_markers = [];
   var cur_bus_times_info = {};
   function draw_bus_times(route, bus_id, map) {
     /* remove previous markers if any */
     while (bus_times_markers.length > 0) {
        bus_times_markers.pop().setMap(null);
     }

     if (route == null) {
        cur_bus_times_info = {};
        return;
     }

     cur_bus_times_info = {route: route, bus_id: bus_id, map: map};

     /* write new markers */
     $.getJSON('/Buses?route=' + route + '&bus_id=' + bus_id, function(buses) {

        /* don't update if they've asked for something else in the mean time */
        if (route != cur_bus_times_info.route ||
            bus_id !=  cur_bus_times_info.bus_id) {
          return;
        }
      
        for (bus_no in buses) {
          var up = buses[bus_no].up;
          for (stop_tag in up) {
             var stop_min = up[stop_tag]; 
             if (route in routes && stop_tag in routes[route].stops) {
                var smarker = routes[route].stops[stop_tag];
                var btmarker = new google.maps.Marker({
                   position: smarker.position,
                   icon: load_time_image(stop_min),
                   map: map});
                btmarker.setZIndex(1200-stop_min);
                bus_times_markers.push(btmarker);
             }
          }
        }
     });
   }

   function color_paths(route, direction)
   {
      if (current_colored_path)
      {
         color_path(current_colored_path[0],
                    current_colored_path[1],
                    get_color("inactive", current_colored_path[0]),
                    default_path_opacity);
      }
      if (route != null) {
        color_path(route, direction, get_color("active",route), active_path_opacity);
        current_colored_path = [route, direction];
      }
      else {
        current_colored_path = [];
      }
   }




   function color_path(route, direction, color, opacity)
   {
      if (!(route in routes) || !("path_lines" in routes[route]) || !(direction in routes[route].path_lines))
      {
         return
      }
      var paths = routes[route].path_lines[direction];

      for (path_no in paths)
      {
         paths[path_no].setOptions({
               "strokeColor" : color,
               "strokeOpacity": opacity
                  });
      }
   }




   function load_time_image(nmin) {
     if (image_cache["min" + nmin] == null) {
        image_cache["min" + nmin] = new google.maps.MarkerImage(
           "static/min" + nmin + ".png",
           new google.maps.Size(78, 42), // size
           new google.maps.Point(0, 0), // origin
           new google.maps.Point(0, 42) //anchor
        );
     }
     return image_cache["min" + nmin];
   }

   var stop_image = new google.maps.MarkerImage(
       "static/rmark.png",
       new google.maps.Size(8, 8), // size
       new google.maps.Point(0, 0), // origin
       new google.maps.Point(4, 4) //anchor
   );

   function curtime() {
      return (new Date()).getTime()/1000;
   }

   function load_heading_image(heading) {
      if (image_cache[heading] == null) {
         image_cache[heading] = new google.maps.MarkerImage(
            "http://www.google.com/intl/en_ALL/mapfiles/dir_" + heading + ".png",
            new google.maps.Size(24, 24), // size
            new google.maps.Point(0, 0), // origin
            new google.maps.Point(12, 12) //anchor
         );
      }
      return image_cache[heading];
   }

   var max_lat = null;
   var min_lat = null;
   var max_lng = null;
   var min_lng = null;

   function distance(x1,y1,x2,y2) {
     // really distance squared, but no one cares
     return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
   }

   function closest_point_on_line(x1, y1, x2, y2, x3, y3) {
      // from http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/
      var u = ((x3-x1)*(x2-x1) + (y3-y1)*(y2-y1)) / distance(x1, y1, x2, y2);

      if (u < 0 || u > 1) {
         // use one of the ends
         if (distance(x1,y1,x3,y3) > distance(x2,y2,x3,y3)) {
             return [x2,y2];
         }
         else {
             return [x1,y1];
         }
      }
      else {
        // use a point on the line

        var x4 = x1 + u*(x2 - x1);
        var y4 = y1 + u*(y2 - y1);

        return [x4,y4];
      }
   }

   function distance_to_line(x1, y1, x2, y2, x3, y3) {
      var cpol = closest_point_on_line(x1, y1, x2, y2, x3, y3);
      return distance(cpol[0], cpol[1], x3, y3);
   }


   function snap_to_path(route, dir, lat, lon) {
     var best_line = null;
     var best_dist = null;

     if (!(route in routes) || !("path_cache" in routes[route]) || !(dir in routes[route].path_cache)) {
        return [lat, lon];
     }

     // only consider paths for this route in this direction
     var paths = routes[route].path_cache[dir];

     for (path_no in paths) {
        for (point_no in paths[path_no]) {
           if (point_no > 0) {
              var p_i = paths[path_no][point_no-1];
              var p_j = paths[path_no][point_no];
              var dist = distance_to_line(p_i.lat, p_i.lon, p_j.lat, p_j.lon, lat, lon);
              if (best_line == null || dist < best_dist) {
                 best_line = [p_i.lat, p_i.lon, p_j.lat, p_j.lon];
                 best_dist = dist;
              }
           }
        }
     }

     if (best_line == null || (best_dist > .00001 && !is_subway(route))) {
        // if we failed to find a good line, or if we'd be adjusting too far, do nothing
        return [lat,lon];
     }
     return closest_point_on_line(best_line[0], best_line[1],
                                  best_line[2], best_line[3],
                                  lat, lon);
   }

   function estimate_pos(age_i, age_j, req_time, l_i, l_j, t_k) {
     var t_i = req_time - age_i;
     var t_j = req_time - age_j;

     if (Math.abs(l_i - l_j) < .00001 || t_i == t_j) {
        return l_j;
     }

     var l_k = l_j + (t_k-t_j)*(l_j-l_i)/(t_j-t_i);
     return l_k;
   }


   function update_bounds(lat, lng) {
     if (max_lat == null || lat > max_lat ) { max_lat = lat; }
     if (min_lat == null || lat < min_lat ) { min_lat = lat; }

     if (max_lng == null || lng < max_lng ) { max_lng = lng; }
     if (min_lng == null || lng > min_lng ) { min_lng = lng; }
   }

   function initialize() {
    var latlng = new google.maps.LatLng(42.3, -71.1);
    var myOptions = {
      zoom: 11,
      center: latlng,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    var map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);

    function recenter () {
       if (max_lat != null && min_lat != null && max_lng != null && min_lng != null) {
          var sw = new google.maps.LatLng(min_lat, max_lng);
          var ne = new google.maps.LatLng(max_lat, min_lng);
          map.fitBounds(new google.maps.LatLngBounds(sw, ne));
       }
    }

    function get_bus_position(bus, route, t_now, timestamp)
    {
       if (document.settings.est.checked) {
          lat = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lat_i, bus.lat_j, t_now);
          lon = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lon_i, bus.lon_j, t_now);
       }
       else
       {
          lat = bus.lat_j;
          lon = bus.lon_j;
       }

       if (document.settings.snap.checked) {
         cpol = snap_to_path(route, bus.dir, lat, lon);
         lat = cpol[0];
         lon = cpol[1];
       }

       return [lat, lon]
    }

    function plot_buses(map, busarr, route) {

       if (!(route in routes) || !("bus_cache" in routes[route])) {
          return;
       }

       timestamp = routes[route].bus_cache[0];
       buses = routes[route].bus_cache[1];

       if (!buses || !busarr) {
         return;
       }


       for (bus_no in buses) {
          var bus = buses[bus_no];
          var busid = route + ":" + bus.dir + ":"+ bus.id;
          var bus_title = busid + " -- age " + bus.age_j;

          var t_now = curtime();
          var lat_lon = get_bus_position(bus, route, t_now, timestamp);
          var lat_lon_1 = get_bus_position(bus, route, t_now+5, timestamp);

          if (document.settings.esth.checked)
          {
             // update heading
             var delta_lat = lat_lon_1[0] - lat_lon[0];
             var delta_lon = lat_lon_1[1] - lat_lon[1];
             if (Math.abs(delta_lat) > 0.000001 && Math.abs(delta_lon) > 0.000001)
             {
                var theta_r = Math.atan2(delta_lon,delta_lat);
                var theta_d = (180*theta_r/Math.PI+360)%360;

                // round to the nearest 3 degrees in the range 0-120
                bus.rhead = Math.round((Math.round(theta_d)%120)/3)*3;
             }
             else {
                bus.rhead = 0;
             }
          }

          var blatlng = new google.maps.LatLng(lat_lon[0], lat_lon[1]);

          function make_marker(bus_id)
          {
             var bmarker = new google.maps.Marker({
                   position: blatlng,
                   bus_id: bus_id,
                   title:bus_title + " (new)",
                   });
             bmarker.setZIndex(999);
             bmarker.setMap(map);
             google.maps.event.addListener(bmarker, "mouseover", function() {
                color_paths(bmarker.bus_route, bmarker.bus_direction);
             });
             google.maps.event.addListener(bmarker, "click", function() {
                 times_info_window.close(); 
                 draw_bus_times(route, bmarker.bus_id, map);
             });
             google.maps.event.addListener(bmarker, "mouseout", function() {
                color_paths(null,null);
             });
             return bmarker;

          }

          if (!(busid in busarr)) {
             busarr[busid] = make_marker(bus.id);
          }

          busarr[busid].setIcon(load_heading_image(bus.rhead));
          busarr[busid].setPosition(blatlng);
          busarr[busid].setTitle(bus_title);
          busarr[busid].bus_route = route;
          busarr[busid].bus_direction = bus.dir;
       }
    }

    function update_route_buses(route) {
         $.getJSON('/Buses?route=' + route, function(buses) {
            routes[route].bus_cache = [curtime(), buses];
         });
    }

    function update_buses() {
       for (route in routes) {
          update_route_buses(route);
       }
    }

    function plot_continual() {
       if (document.settings.running.checked) {
          for (route in routes) {
                plot_buses(map, routes[route].buses, route);
          }
       }
    }

    function update_continual() {
        if (document.settings.running.checked) {
          update_buses();
        }
    }

    function update_bus_times_continual() {
       if (document.settings.running.checked) {
          if (cur_bus_times_info != {}) {
             draw_bus_times(cur_bus_times_info.route,
                            cur_bus_times_info.bus_id,
                            cur_bus_times_info.map);
          }
       }
    }

    function draw_buses_continual(map) {
      update_continual();
      plot_continual();

      setInterval( plot_continual, 500);

      setInterval(function() { document.settings.running.checked = false; },
                  5*60*1000);

      setInterval( update_continual, 15000);

      setInterval( update_bus_times_continual, 10001 );
    }

    function draw_direction(route, direction, map, opacity, weight)
    {
       var paths = routes[route].path_cache[direction];

       for (path_no in paths) {
          var coords = new Array();
          for (point_no in paths[path_no]) {
             var point = paths[path_no][point_no];
             update_bounds(point.lat, point.lon)
                coords.push( new google.maps.LatLng(point.lat, point.lon) );
          }

          var buspath = new google.maps.Polyline({
            path: coords,
                strokeColor: get_color("inactive",route),
                strokeOpacity: opacity,
                strokeWeight: weight
                });

          buspath.setMap(map);
          google.maps.event.addListener(buspath, "click", function() {
             //draw_buses(map, busarr, route);
          });

          routes[route].path_lines[direction].push(buspath);
       }
    }

    function undraw_route(map, route) {
      for (direction in routes[route].path_lines) {
        for (line_no in routes[route].path_lines[direction]) {
          pline = routes[route].path_lines[direction][line_no];
          pline.setMap(null);
          delete routes[route].path_lines[direction][line_no];
        }
        delete routes[route].path_lines[direction];
      }
      delete routes[route].path_lines;
      delete routes[route].path_cache;
      for (bus_no in routes[route].buses) {
        routes[route].buses[bus_no].setMap(null);
        delete routes[route].buses[bus_no];
      }
      delete routes[route].buses;
      for (stop_no in routes[route].stops) {
        routes[route].stops[stop_no].setMap(null);
        delete routes[route].stops[stop_no];
      }
      delete routes[route].stops;
    }
    function draw_route(map, route, should_recenter) {
         routes[route].path_cache = {};
         routes[route].path_lines = {};
         routes[route].buses = [];
         routes[route].stops = {};
         $.getJSON('/Paths?route=' + route, function(r) {

            var opacity = default_path_opacity;
            var weight = 3.0;

            routes[route].path_cache = r.directions;

            for (direction in routes[route].path_cache)
            {
               routes[route].path_lines[direction] = new Array();
               draw_direction(route, direction, map, opacity, weight);
            }

            if (should_recenter) {
              recenter();
            }


            {% if stops %}
              function plot_stop(stop)
              {
                 var slatlng = new google.maps.LatLng(stop.lat, stop.lon);

                 var smarker = new google.maps.Marker({
                    position: slatlng,
                    title: stop.title,
                    titles: [],
                    stop_tag: stop.tag,
                    stop_tags: [stop.tag],
                    icon: stop_image,

                    map: map
                 });

                 routes[route].stops[stop.tag] = smarker;

                 google.maps.event.addListener(smarker, "click", function() {
                    draw_bus_times(null, null, null); // hide bus time markers

                    t = "<h3>" + stop.title;
                    for (title_no in smarker.titles) {
                       t += " / " + smarker.titles[title_no];
                    }
                    t += "</h3>";

                    var all_arrivals = new Array();
                    var errors = new Array();

                    t += "<table border=\"0\">";

                    times_info_window.setContent(t + "<tr><td><tt>[loading ...]</tt></table>");
                    times_info_window.open(map,smarker);

                    function update_arrivals(arrival_info) {

                         var arrival_status = arrival_info[0];
                         var arrivals = arrival_info[1];
                         var stop_tag = arrival_info[2];

                         if (arrival_status == "error") {
                             errors.push([stop_tag, "Predictions unavailable"]);
                         }
                         else if (arrival_status == "none") {
                             //errors.push([stop_tag, "No predicted service"]);
                         }
                         else {
                             for (arrival_no in arrivals)
                             {
                                all_arrivals.push([arrivals[arrival_no][0], arrivals[arrival_no][1], arrivals[arrival_no][2]]);
                             }
                         }

                         all_arrivals.sort(function(a,b) {
                            return a[0]-b[0];
                         });

                         var temp_t = t;

                         for (all_arrival_no in all_arrivals) {
                            var minutes = all_arrivals[all_arrival_no][0];
                            var route = all_arrivals[all_arrival_no][1];
                            var title = all_arrivals[all_arrival_no][2];

                            if (minutes == "0") { minutes = "nowish"; }
                            else { minutes += "min" ; }

                            temp_t += "<tr><td align=\"right\">" + minutes + ":</td><td>" + route + " " + title + "</td></tr>";
                         }

                         for (error_no in errors) {
                            temp_t += "<tr><td>Stop " + errors[error_no][0] + ":<td>" + errors[error_no][1];
                         }

                         times_info_window.setContent(temp_t + "</table>");
                         times_info_window.open(map,smarker);
                    }

                    for (tag_no in smarker.stop_tags) {
                       $.getJSON('/Arrivals?stop=' + smarker.stop_tags[tag_no], function(arrival_info) {
                          update_arrivals(arrival_info);
                       });
                    }
                 });
              }

              for (stop_no in r.stops) {
                 plot_stop(r.stops[stop_no]);
              }

              merge_stop_predictions(map);

            {% endif %}

         });

    }

    $("#route_adder").change(enable_route_from_event);
    $("#route_deler").change(disable_route_from_event);
                         
    function reload_selects() {
      $.getJSON("/Routes", function(route_names) {

        $('#route_adder').find('option').remove().end().append(
             '<option value"">Add Route</option>');
        $('#route_deler').find('option').remove().end().append(
             '<option value"">Remove Route</option>');
                         
        for (route_no in route_names) {
           route_id = route_names[route_no][0];
           route_displayname = route_names[route_no][1];

           use_box = "#route_adder";
           if (route_id in routes) {
              use_box = "#route_deler";
           }
                         
           $(use_box).append('<option value="' + route_id + '">' +
                 route_displayname + '</option>');
           }
        }
      );
    }

    function disable_route_from_event(event) {
       disable_route($('#route_deler').val());
    }
               
    function enable_route_from_event(event) {
       enable_route($('#route_adder').val(), false);
    }

    function disable_route(route) {
      if (route == undefined || !(route in routes)) {
         return;
      }
      undraw_route(map, route);
               
      delete routes[route];
      reload_selects();
    }
               
    function enable_route(route, should_recenter) {
      if (route == undefined || route in routes) {
         return;
      }

      routes[route] = {};
      draw_route(map, route, should_recenter);
      plot_buses(map, routes[route].buses, route);
      reload_selects();
    }

    {% for route in routes %}
        enable_route("{{route}}", true);
    {% endfor %}


    google.maps.event.addListener(map, 'zoom_changed', function() {
       merge_stop_predictions(map);
    });
    merge_stop_predictions(map);


    {% if buses %}
       draw_buses_continual(map);
    {% endif %}

   }

</script>
</head>
<body onload="initialize()">
  <div id="all" style="height: 100%">
  <noscript>
     Error: either you have javascript disabled or your browser does
     not support it.  This mapping tool makes extensive use of
     javascript and will not work without it.  Please consider
     enabling javascript or using a more recent browser
  </noscript>
  <div id="map_canvas"></div>
  <div id="options">

    <form name="settings">
      <select id="route_adder">
         <option value="">Add (loading)</option>
      </select>

      <select id="route_deler">
         <option value="">Remove (loading)</option>
      </select>

      &nbsp;&nbsp;&nbsp;

      <input type="checkbox" name="est" checked="{{est}}"> Estimate Locations &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="esth" checked="true"> Estimate Headings &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="snap" checked="{{snap}}"> Snap to Route &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="running" checked="true"> Running &nbsp;&nbsp;&nbsp;
      <a href="/">intro</a>




    </form>



  </div>
  </div>
</body> </html>
