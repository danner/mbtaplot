<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html,body,all
{
  height: 100%;
  margin: 0px;
  padding: 0px;
}

#map_canvas
{
  width:100%;
  height:94%;
}

#options
{
   width:100%;
   height:1.4em;
   clear: both;
}

</style>
<script type="text/javascript" src="static/jquery-1.4.2.min.js"></script>
<script type="text/javascript"
    src="http://maps.google.com/maps/api/js?sensor=false">
</script>
<script type="text/javascript">
   var default_path_opacity = 0.5;
   var active_path_opacity = 1.0;



   var image_cache = new Object(); // heading -> marker
   var path_cache = new Object();  // route -> direction -> paths[points[]]
   var path_lines = new Object();  // route -> direction -> polylines[]
   var bus_cache = new Object();   // route -> bus[]

   var current_colored_path = null;

   function get_color(active, route) {
      colors = {"Red": {"active": "#CC0000",
                        "inactive": "#FF0000"},
                "Orange": {"active": "#FF7700",
                           "inactive": "#FF5500"},
                "Blue": {"active": "#0000CC",
                         "inactive": "#1900FF"},
                "Bus": {"active": "#B404AE",
                        "inactive": "#FE2EF7"}}
      if (route in colors) { return colors[route][active]; }
      else { return colors["Bus"][active]; }
   }


   function is_subway(route) {
     return route == "Red" || route == "Blue" || route == "Orange";
   }

   function color_paths(route, direction)
   {
      if (current_colored_path)
      {
         color_path(current_colored_path[0],
                    current_colored_path[1],
                    get_color("inactive", current_colored_path[0]),
                    default_path_opacity);
      }

      color_path(route, direction, get_color("active",route), active_path_opacity);
      current_colored_path = [route, direction];
   }




   function color_path(route, direction, color, opacity)
   {
      if (!(route in path_lines) || !(direction in path_lines[route]))
      {
         return
      }
      var paths = path_lines[route][direction];

      for (path_no in paths)
      {
         paths[path_no].setOptions({
               "strokeColor" : color,
               "strokeOpacity": opacity
                  });
      }
   }







   var stop_image = new google.maps.MarkerImage(
       "static/stop.png",
       new google.maps.Size(8, 8), // size
       new google.maps.Point(0, 0), // origin
       new google.maps.Point(4, 4) //anchor
   );

   function curtime() {
      return (new Date()).getTime()/1000;
   }

   function load_image(heading) {
      if (image_cache[heading] == null) {
         image_cache[heading] = new google.maps.MarkerImage(
            "http://www.google.com/intl/en_ALL/mapfiles/dir_" + heading + ".png",
            new google.maps.Size(24, 24), // size
            new google.maps.Point(0, 0), // origin
            new google.maps.Point(12, 12) //anchor
         );
      }
      return image_cache[heading];
   }

   var max_lat = null;
   var min_lat = null;
   var max_lng = null;
   var min_lng = null;

   function distance(x1,y1,x2,y2) {
     // really distance squared, but no one cares
     return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
   }

   function closest_point_on_line(x1, y1, x2, y2, x3, y3) {
      // from http://local.wasp.uwa.edu.au/~pbourke/geometry/pointline/
      var u = ((x3-x1)*(x2-x1) + (y3-y1)*(y2-y1)) / distance(x1, y1, x2, y2);

      if (u < 0 || u > 1) {
         // use one of the ends
         if (distance(x1,y1,x3,y3) > distance(x2,y2,x3,y3)) {
             return [x2,y2];
         }
         else {
             return [x1,y1];
         }
      }
      else {
        // use a point on the line

        var x4 = x1 + u*(x2 - x1);
        var y4 = y1 + u*(y2 - y1);

        return [x4,y4];
      }
   }

   function distance_to_line(x1, y1, x2, y2, x3, y3) {
      var cpol = closest_point_on_line(x1, y1, x2, y2, x3, y3);
      return distance(cpol[0], cpol[1], x3, y3);
   }


   function snap_to_path(route, dir, lat, lon) {
     var best_line = null;
     var best_dist = null;

     if (!(route in path_cache) || !(dir in path_cache[route])) {
        return [lat, lon];
     }

     // only consider paths for this route in this direction
     var paths = path_cache[route][dir];

     for (path_no in paths) {
        for (point_no in paths[path_no]) {
           if (point_no > 0) {
              var p_i = paths[path_no][point_no-1];
              var p_j = paths[path_no][point_no];
              var dist = distance_to_line(p_i.lat, p_i.lon, p_j.lat, p_j.lon, lat, lon);
              if (best_line == null || dist < best_dist) {
                 best_line = [p_i.lat, p_i.lon, p_j.lat, p_j.lon];
                 best_dist = dist;
              }
           }
        }
     }

     if (best_line == null || (best_dist > .00001 && !is_subway(route))) {
        // if we failed to find a good line, or if we'd be adjusting too far, do nothing
        return [lat,lon];
     }
     return closest_point_on_line(best_line[0], best_line[1],
                                  best_line[2], best_line[3],
                                  lat, lon);
   }

   function estimate_pos(age_i, age_j, req_time, l_i, l_j, t_k) {
     var t_i = req_time - age_i;
     var t_j = req_time - age_j;

     if (Math.abs(l_i - l_j) < .00001 || t_i == t_j) {
        return l_j;
     }

     var l_k = l_j + (t_k-t_j)*(l_j-l_i)/(t_j-t_i);
     return l_k;
   }


   function update_bounds(lat, lng) {
     if (max_lat == null || lat > max_lat ) { max_lat = lat; }
     if (min_lat == null || lat < min_lat ) { min_lat = lat; }

     if (max_lng == null || lng < max_lng ) { max_lng = lng; }
     if (min_lng == null || lng > min_lng ) { min_lng = lng; }
   }

   function initialize() {
    var latlng = new google.maps.LatLng(42.3, -71.1);
    var myOptions = {
      zoom: 11,
      center: latlng,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    var map = new google.maps.Map(document.getElementById("map_canvas"), myOptions);

    function recenter () {
       if (max_lat != null && min_lat != null && max_lng != null && min_lng != null) {
          var sw = new google.maps.LatLng(min_lat, max_lng);
          var ne = new google.maps.LatLng(max_lat, min_lng);
          map.fitBounds(new google.maps.LatLngBounds(sw, ne));
       }
    }

    function get_bus_position(bus, route, t_now, timestamp)
    {
       if (document.settings.est.checked) {
          lat = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lat_i, bus.lat_j, t_now);
          lon = estimate_pos(bus.age_i, bus.age_j, timestamp, bus.lon_i, bus.lon_j, t_now);
       }
       else
       {
          lat = bus.lat_j;
          lon = bus.lon_j;
       }

       if (document.settings.snap.checked) {
         cpol = snap_to_path(route, bus.dir, lat, lon);
         lat = cpol[0];
         lon = cpol[1];
       }

       return [lat, lon]
    }


    function plot_buses(map, busarr, route) {
       if (!(route in bus_cache)) {
          return;
       }

       timestamp = bus_cache[route][0];
       buses = bus_cache[route][1];

       for (bus_no in buses) {
          var bus = buses[bus_no];
          var busid = route + ":" + bus.dir + ":"+ bus.id;
          var bus_title = busid + " -- age " + bus.age_j;

          var t_now = curtime();
          var lat_lon = get_bus_position(bus, route, t_now, timestamp);
          var lat_lon_1 = get_bus_position(bus, route, t_now+5, timestamp);

          if (document.settings.esth.checked)
          {
             // update heading
             var delta_lat = lat_lon_1[0] - lat_lon[0];
             var delta_lon = lat_lon_1[1] - lat_lon[1];
             if (Math.abs(delta_lat) > 0.000001 && Math.abs(delta_lon) > 0.000001)
             {
                var theta_r = Math.atan2(delta_lon,delta_lat);
                var theta_d = (180*theta_r/Math.PI+360)%360;

                // round to the nearest 3 degrees in the range 0-120
                bus.rhead = Math.round((Math.round(theta_d)%120)/3)*3;
             }
             else {
                bus.rhead = 0;
             }
          }

          var blatlng = new google.maps.LatLng(lat_lon[0], lat_lon[1]);

          function make_marker()
          {
             var bmarker = new google.maps.Marker({
                   position: blatlng,
                   title:bus_title + " (new)"
                   });
             bmarker.setMap(map);
             google.maps.event.addListener(bmarker, "click", function() {
                color_paths(bmarker.bus_route, bmarker.bus_direction);
             });
             return bmarker;

          }

          if (!(busid in busarr)) {
             busarr[busid] = make_marker();
          }

          busarr[busid].setIcon(load_image(bus.rhead));
          busarr[busid].setPosition(blatlng);
          busarr[busid].setTitle(bus_title);
          busarr[busid].bus_route = route;
          busarr[busid].bus_direction = bus.dir;
       }
    }


    function update_buses(route) {
        $.getJSON('/Buses?route=' + route, function(buses) {
            bus_cache[route] = [curtime(), buses];
        });
    }

    function draw_buses_continual(map, busarr, route) {
      update_buses(route);

      setInterval(function()
        {
          if (document.settings.running.checked) {
            plot_buses(map, busarr, route);
          }
        },
        500
      );

      setInterval(function() { document.settings.running.checked = false; },
                  5*60*1000);


      var update_interval = 15000;
      //if (is_subway(route)) {
      //    update_interval = 45000;
      //}

      setInterval(function() { if (document.settings.running.checked) { update_buses(route); } },
                  update_interval);
    }

    function draw_direction(route, direction, map, opacity, weight)
    {
       var paths = path_cache[route][direction];

       for (path_no in paths) {
          var coords = new Array();
          for (point_no in paths[path_no]) {
             var point = paths[path_no][point_no];
             update_bounds(point.lat, point.lon)
                coords.push( new google.maps.LatLng(point.lat, point.lon) );
          }

          var buspath = new google.maps.Polyline({
            path: coords,
                strokeColor: get_color("inactive",route),
                strokeOpacity: opacity,
                strokeWeight: weight
                });

          buspath.setMap(map);
          google.maps.event.addListener(buspath, "click", function() {
             //draw_buses(map, busarr, route);
          });

          path_lines[route][direction].push(buspath);
       }
    }

    function draw_routes(map, route, busarr) {

      {% if shading %}
      $.getJSON('/Buses?route=' + route, function(buses) {
         var n_buses = buses.length;
         var opacity = n_buses/10;
         //var opacity = 1.0;
         var weight = n_buses/8+1;
         //var weight = n_buses/4+1;
      {% else %}
         var opacity = default_path_opacity;
         var weight = 3.0;
      {% endif %}

         $.getJSON('/Paths?route=' + route, function(r) {
            path_cache[route] = r.directions;
            path_lines[route] = new Object();

            for (direction in path_cache[route])
            {
               path_lines[route][direction] = new Array();
               draw_direction(route, direction, map, opacity, weight);
            }

            recenter();


            {% if stops %}
              stop_info_window = new google.maps.InfoWindow({
                    content: "not set yet"
              });

              function plot_stop(stop)
              {
                 var slatlng = new google.maps.LatLng(stop.lat, stop.lon);

                 var smarker = new google.maps.Marker({
                    position: slatlng,
                    title: stop.title,
                    icon: stop_image,

                    map: map
                 });

                 google.maps.event.addListener(smarker, "click", function() {
                    t = "<h3>" + stop.title + "</h3>";
                    stop_info_window.setContent(t + "<tt>[loading ...]</tt>");

                    $.getJSON('/Arrivals?stop=' + stop.tag, function(arrival_info)
                    {
                       var arrival_status = arrival_info[0];
                       var arrivals = arrival_info[1];

                       if (arrival_status == "error") {
                           t += "Predictions unavailable"
                       }
                       else if (arrival_status == "none") {
                           t += "No predicted stops"
                       }
                       else {
                           t += "<table border=\"0\">";
                           for (arrival_no in arrivals)
                           {
                              var minutes = arrivals[arrival_no][0];
                              var route = arrivals[arrival_no][1];
                               var title = arrivals[arrival_no][2];

                              if (minutes == "0") { minutes = "nowish"; }
                              else { minutes += "min" ; }

                              t += "<tr><td align=\"right\">" + minutes + ":</td><td>" + route + " " + title + "</td></tr>";
                           }
                           t += "</table>";
                       }

                       stop_info_window.setContent(t);
                    });

                    stop_info_window.open(map,smarker);

                 });
              }

              for (stop_no in r.stops) {
                 plot_stop(r.stops[stop_no]);
              }

            {% endif %}

            {% if buses %}
               draw_buses_continual(map, busarr, route);
            {% endif %}
         });

      {% if shading %}
      });
      {% endif %}
    }

    {% for route in routes %}
        draw_routes(map, "{{route}}", new Object());
    {% endfor %}

   }





</script>
</head>
<body onload="initialize()">
  <div id="all" style="height: 100%">
  <noscript>
     Error: either you have javascript disabled or your browser does
     not support it.  This mapping tool makes extensive use of
     javascript and will not work without it.  Please consider
     enabling javascript or using a more recent browser
  </noscript>
  <div id="map_canvas"></div>
  <div id="options">

    <form name="settings">
      <input type="checkbox" name="est" checked="{{est}}"> Estimate Locations &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="esth" checked="true"> Estimate Headings &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="snap" checked="{{snap}}"> Snap to Route &nbsp;&nbsp;&nbsp;
      <input type="checkbox" name="running" checked="true"> Running &nbsp;&nbsp;&nbsp;
      <a href="/">other routes</a>
    </form>



  </div>
  </div>
</body> </html>
